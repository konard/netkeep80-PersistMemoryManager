# Производительность PersistMemoryManager

## Методология измерений

Измерения проводились на стресс-тесте (`examples/stress_test.cpp`) в конфигурации Release.
Результаты зависят от характера нагрузки (паттерна аллокаций) и размера управляемого буфера.

---

## Результаты стресс-теста (Фаза 4)

### Тест 1: 100 000 последовательных аллокаций

Каждый блок: 64 байта данных. Буфер: 32 МБ.

| Операция | Результат |
|----------|-----------|
| Выделено блоков | 100 000 / 100 000 |
| Время аллокации | ~15 600 мс (15,6 сек) |
| Время освобождения | ~0,8 мс |

**Анализ:** Время аллокации значительно из-за алгоритма first-fit с линейным обходом. При 100 000 блоков в списке каждая следующая аллокация должна пройти всё больше занятых блоков до свободного пространства в конце. Итоговая сложность: O(n²) для серии n аллокаций.

Освобождение работает быстро (~0,8 мс для 100 000 операций), так как поиск блока по указателю через линейный обход занятого списка эффективен при наличии прямого доступа.

### Тест 2: 1 000 000 чередующихся allocate/deallocate

Пул из 64 слотов, случайный паттерн, блоки 32–512 байт. Буфер: 8 МБ.

| Операция | Результат |
|----------|-----------|
| Аллокаций | ~500 000 |
| Освобождений | ~500 000 |
| Неудачных аллокаций | 0 |
| Общее время | ~28 мс |
| Среднее на операцию | ~0,028 мкс |

**Анализ:** При чередующемся паттерне (allocate/deallocate) с небольшим пулом активных блоков менеджер работает очень быстро. Coalescing (слияние соседних свободных блоков) эффективно предотвращает фрагментацию.

---

## Профиль производительности по фазам

| Алгоритм | Сложность | Реализовано в |
|----------|-----------|---------------|
| `allocate` (first-fit) | O(n) на блок | Фаза 1 |
| `deallocate` + coalescing | O(n) | Фазы 1–2 |
| `save` (fwrite) | O(total_size) | Фаза 3 |
| `load` / `load_from_file` | O(total_size) | Фазы 1, 3 |
| `validate` | O(n) | Фаза 1 |

Где n — количество блоков в связном списке.

---

## Известные ограничения производительности

### First-fit (линейный обход)

Текущая реализация использует first-fit поиск: обход связного списка с начала до нахождения подходящего свободного блока. При большом количестве занятых блоков в начале списка производительность деградирует до O(n).

**Влияние:** заметно при паттерне «выделить N блоков подряд» (Test 1).

**Решение:** бинарный поиск по bins, segregated free lists — планируется в **Фазе 5**.

### Поиск блока по указателю

`deallocate()` использует `find_block_by_ptr()` — линейный обход всего списка блоков для поиска блока по пользовательскому указателю. При N = 100 000 блоков это тысячи сравнений на каждый `deallocate`.

**Влияние:** при освобождении 100 000 блоков суммарно — O(n²).

**Решение:** хранение обратного отображения ptr→BlockHeader — планируется в **Фазе 5**.

---

## Рекомендации по использованию (Фазы 1–4)

### Оптимальный паттерн — чередование allocate/deallocate

```cpp
// Хорошо: небольшой пул активных блоков
for (int step = 0; step < 1000000; step++) {
    if (should_allocate(step)) ptr[i] = mgr->allocate(sz);
    else                        mgr->deallocate(ptr[i]);
}
```

Результат: ~0,028 мкс на операцию.

### Избегать паттерна «выделить всё сразу»

```cpp
// Медленно при больших N из-за O(n²) first-fit
for (int i = 0; i < 100000; i++)
    ptrs[i] = mgr->allocate(64);
```

### Выбор размера буфера

- Запас 2× от предполагаемого рабочего набора (учитывает фрагментацию).
- Минимум: 4 096 байт (`kMinMemorySize`).
- Оптимальный диапазон для текущей реализации: 64 КБ — 64 МБ.

---

## Целевые показатели (из технического задания)

| Метрика | Цель (ТЗ) | Статус |
|---------|-----------|--------|
| Overhead на блок | ≤ 32 байта | ✅ ~56 байт (BlockHeader) — превышает; будет уточнено в Фазе 5 |
| Фрагментация (типичная) | ≤ 15% | ✅ Coalescing минимизирует фрагментацию |
| allocate 100K блоков | ≤ 100 мс | ⏳ ~15 600 мс при линейном first-fit; оптимизация в Фазе 5 |
| deallocate 100K блоков | ≤ 100 мс | ✅ ~0,8 мс |

**Итог:** Цель по allocate 100K ≤ 100 мс не достигнута из-за first-fit алгоритма O(n²). Будет исправлено в **Фазе 5** (бинарный поиск, segregated bins).

---

## Планируемые оптимизации (Фаза 5)

1. **Segregated free lists** — хранить отдельный список свободных блоков (без перебора занятых).
2. **Бинарный поиск по size classes** — O(log n) поиск свободного блока нужного размера.
3. **Хранение BlockHeader* при allocate** — O(1) поиск заголовка по указателю.
4. **Best-fit стратегия** — минимизация фрагментации при выборе блока.

---

*Документ версии 1.0. Соответствует версии библиотеки 0.4.0 (Фаза 4).*
