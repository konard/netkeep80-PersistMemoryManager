# Справочник по API PersistMemoryManager

## Обзор

`PersistMemoryManager` — single-header C++17 библиотека управления персистентной кучей памяти.
Вся реализация находится в одном файле: `include/persist_memory_manager.h`.

Пространство имён: `pmm`

---

## Подключение

```cpp
#include "persist_memory_manager.h"
```

Никаких `.cpp` файлов, никакой линковки — только включите заголовок.

---

## Класс `PersistMemoryManager`

```cpp
namespace pmm {
    class PersistMemoryManager;
}
```

Все объекты создаются и уничтожаются через статические методы — прямой вызов конструктора/деструктора не предусмотрен.

### Статические методы инициализации

#### `create()`

```cpp
static PersistMemoryManager* create(void* memory, std::size_t size);
```

Создаёт новый менеджер памяти в переданном буфере.

**Параметры:**
- `memory` — указатель на буфер. Не должен быть `nullptr`.
- `size` — размер буфера в байтах. Должен быть ≥ `kMinMemorySize` (4096).

**Возвращает:** указатель на менеджер или `nullptr` при ошибке.

**Предусловия:** буфер валиден и имеет размер ≥ 4096 байт.

**Постусловия:** возвращённый указатель совпадает с `memory`.

**Пример:**
```cpp
void* mem = std::malloc(1024 * 1024);
auto* mgr = pmm::PersistMemoryManager::create(mem, 1024 * 1024);
// mgr != nullptr при успехе
```

---

#### `load()`

```cpp
static PersistMemoryManager* load(void* memory, std::size_t size);
```

Загружает менеджер из существующего образа в памяти. Проверяет магическое число и размер.

**Параметры:**
- `memory` — буфер с ранее сохранённым образом.
- `size` — размер образа (должен совпадать с `total_size` из заголовка).

**Возвращает:** указатель на менеджер или `nullptr`, если образ некорректен.

**Пример:**
```cpp
// После fread(memory, 1, file_size, f):
auto* mgr = pmm::PersistMemoryManager::load(memory, file_size);
```

---

### Методы уничтожения

#### `destroy()`

```cpp
void destroy();
```

Обнуляет метаданные менеджера в управляемом буфере. Системную память (`memory` из `malloc`) нужно освобождать отдельно через `std::free`.

**Постусловие:** менеджер недействителен, буфер можно освобождать.

**Пример:**
```cpp
mgr->destroy();
std::free(mem);
```

---

### Выделение и освобождение памяти

#### `allocate()`

```cpp
void* allocate(std::size_t size, std::size_t alignment = 16);
```

Выделяет блок памяти внутри управляемой области.

**Параметры:**
- `size` — запрошенный размер блока в байтах. Должен быть > 0.
- `alignment` — выравнивание адреса (по умолчанию 16). Должно быть степенью двойки в диапазоне [8, 4096].

**Возвращает:** выровненный указатель на пользовательские данные или `nullptr` при ошибке (нет памяти, неверное выравнивание, `size == 0`).

**Алгоритм:** first-fit (линейный обход связного списка блоков). При нахождении блока достаточного размера он разделяется, если остаток ≥ 32 байт.

**Пример:**
```cpp
void* p1 = mgr->allocate(256);          // выравнивание 16
void* p2 = mgr->allocate(1024, 32);    // выравнивание 32
void* p3 = mgr->allocate(64, 4096);    // выравнивание 4096 (страничное)
```

---

#### `deallocate()`

```cpp
void deallocate(void* ptr);
```

Освобождает блок, ранее выделенный через `allocate()`. После освобождения выполняется слияние соседних свободных блоков (coalescing).

**Параметры:**
- `ptr` — указатель, полученный от `allocate()`. `nullptr` допустим (нет операции).

**Предусловие:** `ptr` должен быть указателем на начало пользовательских данных занятого блока.

**Пример:**
```cpp
mgr->deallocate(p1);  // OK
mgr->deallocate(nullptr);  // нет операции
```

---

### Персистентность

#### `save()`

```cpp
bool save(const char* filename) const;
```

Сохраняет образ управляемой области памяти в двоичный файл.

**Параметры:**
- `filename` — путь к выходному файлу. Не должен быть `nullptr`.

**Возвращает:** `true` при успешной записи, `false` при ошибке.

**Поведение:** записывает весь буфер (от начала до `total_size` байт) в файл через `fwrite`. Образ самодостаточен — содержит все метаданные.

**Пример:**
```cpp
if (!mgr->save("heap.dat")) {
    // ошибка записи
}
```

---

### Метрики

#### `total_size()`

```cpp
std::size_t total_size() const;
```

Возвращает полный размер управляемой области (равен `size`, переданному в `create()`).

---

#### `used_size()`

```cpp
std::size_t used_size() const;
```

Возвращает объём занятой памяти: метаданные (заголовки) плюс пользовательские данные.

---

#### `free_size()`

```cpp
std::size_t free_size() const;
```

Возвращает объём доступной свободной памяти внутри управляемой области.

**Инвариант:** `used_size() + free_size() <= total_size()`.

---

#### `fragmentation()`

```cpp
std::size_t fragmentation() const;
```

Возвращает суммарный объём памяти в свободных блоках, которые нельзя использовать из-за фрагментации (разница между общим свободным пространством и размером наибольшего свободного блока).

---

### Диагностика

#### `validate()`

```cpp
bool validate() const;
```

Выполняет полную проверку целостности структур данных:
- Проверяет магические числа `ManagerHeader` и каждого `BlockHeader`.
- Проверяет связность двусвязного списка блоков.
- Проверяет счётчики блоков.

**Возвращает:** `true`, если все структуры корректны.

**Примечание:** O(n) — линейный обход всех блоков. Используется для отладки.

---

#### `dump_stats()`

```cpp
void dump_stats() const;
```

Выводит в `std::cout` диагностическую информацию: размеры, счётчики блоков, фрагментацию.

---

## Свободные функции

### `load_from_file()`

```cpp
namespace pmm {
    PersistMemoryManager* load_from_file(
        const char* filename,
        void*       memory,
        std::size_t size
    );
}
```

Загружает образ менеджера из файла в существующий буфер.

**Параметры:**
- `filename` — путь к файлу с образом.
- `memory` — буфер для загрузки. Размер должен быть ≥ размера файла.
- `size` — размер буфера в байтах.

**Возвращает:** указатель на восстановленный менеджер или `nullptr` при ошибке.

**Алгоритм:**
1. Проверить аргументы на null/0.
2. Открыть файл в режиме `"rb"`.
3. Определить размер файла через `fseek(SEEK_END)` + `ftell()`.
4. Если `file_size > size` → вернуть `nullptr`.
5. Прочитать файл в `memory`.
6. Вызвать `PersistMemoryManager::load(memory, file_size)`.

**Пример:**
```cpp
void* buf = std::malloc(1024 * 1024);
auto* mgr = pmm::load_from_file("heap.dat", buf, 1024 * 1024);
if (mgr != nullptr && mgr->validate()) {
    // образ корректно загружен
}
```

---

### `get_stats()`

```cpp
namespace pmm {
    MemoryStats get_stats(const PersistMemoryManager* mgr);
}
```

Возвращает структуру со статистикой состояния менеджера.

**Параметры:**
- `mgr` — указатель на менеджер. Не должен быть `nullptr`.

**Возвращает:** `MemoryStats` с заполненными полями.

---

### `get_info()`

```cpp
namespace pmm {
    AllocationInfo get_info(const PersistMemoryManager* mgr, void* ptr);
}
```

Возвращает информацию о конкретном выделенном блоке.

**Параметры:**
- `mgr` — указатель на менеджер.
- `ptr` — указатель на пользовательские данные (полученный из `allocate()`).

**Возвращает:** `AllocationInfo`. Поле `is_valid = false`, если блок не найден.

---

## Структуры данных

### `MemoryStats`

```cpp
struct MemoryStats {
    std::size_t total_blocks;        // Общее количество блоков
    std::size_t free_blocks;         // Количество свободных блоков
    std::size_t allocated_blocks;    // Количество занятых блоков
    std::size_t largest_free;        // Размер наибольшего свободного блока (байт)
    std::size_t smallest_free;       // Размер наименьшего свободного блока (байт)
    std::size_t total_fragmentation; // Суммарная фрагментация (байт)
};
```

---

### `AllocationInfo`

```cpp
struct AllocationInfo {
    void*       ptr;       // Указатель на данные пользователя
    std::size_t size;      // Размер пользовательских данных (байт)
    std::size_t alignment; // Выравнивание
    bool        is_valid;  // true — блок найден и корректен
};
```

---

### `ErrorCode`

```cpp
enum class ErrorCode {
    OK = 0,             // Успешное завершение
    OUT_OF_MEMORY,      // Недостаточно памяти
    INVALID_POINTER,    // Неверный указатель
    INVALID_ALIGNMENT,  // Неверное выравнивание (не степень двойки или вне [8,4096])
    CORRUPTED_METADATA, // Повреждённые метаданные (неверное магическое число)
    FILE_IO_ERROR       // Ошибка файлового ввода/вывода
};
```

---

### `Result`

```cpp
struct Result {
    ErrorCode   code;    // Код ошибки
    const char* message; // Текстовое описание
};
```

---

## Константы

| Константа | Значение | Описание |
|-----------|----------|----------|
| `kDefaultAlignment` | 16 | Выравнивание по умолчанию (байт) |
| `kMinAlignment` | 8 | Минимальное выравнивание (байт) |
| `kMaxAlignment` | 4096 | Максимальное выравнивание (байт) |
| `kMinMemorySize` | 4096 | Минимальный размер буфера (байт) |
| `kMinBlockSize` | 32 | Минимальный размер блока данных (байт) |

---

## Коды ошибок и поведение граничных условий

| Условие | Возвращаемое значение |
|---------|----------------------|
| `create(nullptr, size)` | `nullptr` |
| `create(mem, < 4096)` | `nullptr` |
| `allocate(0)` | `nullptr` |
| `allocate(size, нечётное)` | `nullptr` |
| `allocate(size, > 4096)` | `nullptr` |
| `allocate(> free_size)` | `nullptr` |
| `deallocate(nullptr)` | нет операции |
| `save(nullptr)` | `false` |
| `load_from_file(nullptr, ...)` | `nullptr` |
| `load_from_file(file, nullptr, ...)` | `nullptr` |
| `load_from_file(несуществующий файл, ...)` | `nullptr` |
| `load_from_file(файл > size, ...)` | `nullptr` |
| `load(повреждённый образ, ...)` | `nullptr` |

---

## Потокобезопасность

Текущая реализация (Фазы 1–4) **не является потокобезопасной**. Все операции должны вызываться из одного потока или защищаться внешней синхронизацией.

---

## Ограничения

- Файловый ввод/вывод: только `stdio` (`fopen`/`fread`/`fwrite`/`fclose`). Нет поддержки `mmap`.
- Алгоритм поиска блока: first-fit (линейный). Оптимизация — в Фазе 5.
- Нет сжатия или шифрования образа.
- Нет поддержки `reallocate()` (будет в Фазе 5).

---

*Документ версии 1.0. Соответствует версии библиотеки 0.4.0 (Фаза 4).*
